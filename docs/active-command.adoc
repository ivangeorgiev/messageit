== Active Command/Exception

=== Initial Implementation (v1)

This is an implementation of the Command pattern.

[source,python]
----
from abc import ABC, abstractmethod
from typing import Any

class Command(ABC):

    @abstractmethod
    def execute(self) -> Any:
        """Execute the command"""

class Event(ABC):

    @abstractmethod
    def handle(self) -> Any:
        """Handle event"""
----

Usage

[source,python]
----
from dataclasses import dataclass

@dataclass
class LoadFileCommand(Command):
    name: str = __file__

    def execute(self) -> Any:
        print(f"EXECUTE command: {self.name}")
        with open(self.name) as f:
            content = f.read()
        FileLoadedEvent(name=self.name, content=content).handle()
        return content


@dataclass
class FileLoadedEvent(Event):
    name: str
    content: str

    def handle(self) -> Any:
        print(f"HANDLE FileLoadedEvent: {self.name}")
    

def main():
    command = LoadFileCommand()
    command.execute()

if __name__ == "__main__":
    main()
----

Example output:

----
EXECUTE command: messageit\examples\ex2\v1.py
HANDLE <class 'messageit.examples.ex2.v1.FileLoadedEvent'>: messageit\src\messageit\examples\ex2\v1.py
----

==== Pros

- Simple and straightforward

==== Cons

- Command execution and event handling is hard-coded
- Too much responsibility - store parameters and execution logic. One scenario this could be problematic is serialization/deserialization
- What if we want to have centralized logic, e.g. unconditional command and event logging or filtering

=== Applying Strategy Pattern (v2)

We could apply the Strategy pattern to dynamically specify command and event logic.

[source,python]
----
from abc import ABC
from collections import defaultdict
from typing import Any, Callable

class Command(ABC):
    def execute(self) -> Any:
        """Execute the command"""
        self.executor()

    def executor(self) -> Any:
        pass

class Event(ABC):
    observers = defaultdict(list)

    @classmethod
    def observe(cls, observer):
        cls.observers[cls].append(observer)

    def handle(self) -> Any:
        """Handle event"""
        for observe in self.observers[self.__class__]:
            try:
                observe(self)
            except Exception as exception:
                self.logger.exception("Exception publishing event %s", exception)
----

With this implementation one could specify multiple event handlers dynamically. Now the event handling logic is decoupled from the `Event` class defintion.

The default execution logic for `Command` is dummy. The client class could override it.

[source,python]
----
from dataclasses import dataclass

@dataclass
class LoadFileCommand(Command):
    name: str = __file__


@dataclass
class FileLoadedEvent(Event):
    name: str
    content: str
    

def load_file(cmd: LoadFileCommand):
    print(f"EXECUTE load_file: {cmd.name}")
    with open(cmd.name) as f:
        content = f.read()
    FileLoadedEvent(name=cmd.name, content=content).handle()
    return content

def on_file_loaded(event: FileLoadedEvent):
    print(f"HANDLE FileLoadedEvent: {event.name}")


def main():
    # Configure file loading algorithm
    LoadFileCommand.executor = load_file
    # Configure file loaded event handling algorithm
    FileLoadedEvent.observe(on_file_loaded)

    command = LoadFileCommand()
    command.execute()
----

The `v2` implementation solves the hard-coded logic. The implementation for command execution and event handling could be specified at runtime.


=== Extract execution logic (v3)

Framework part of our solution might look like following:

[source,python]
----
class Command(ABC):
    ...

class Event(ABC):
    ...

class CommandExecutor:
    executors: dict

    def __init__(self):
        self.executors = {}

    def execute(self, command: Command) -> Any:
        execute = self.executors.get(type(command), None)
        if execute is None:
            raise ValueError(f"Handler not defined for {command}")
        return execute(command)

class EventHandler:
    observers: DefaultDict

    def __init__(self):
        self.observers = DefaultDict(list)

    def observe(self, event_type, observer):
        self.observers[event_type].append(observer)

    def handle(self, event: Event) -> Any:
        """Handle event"""
        for observe in self.observers[type(event)]:
            try:
                observe(event)
            except Exception as exception:
                self.logger.exception("Exception publishing event %s", exception)
----

We used the Mediator pattern to decouple application components from each other.

Example usage could be like follows:

[source,python]
----
from dataclasses import dataclass

@dataclass
class LoadFileCommand(Command):
    name: str = __file__


@dataclass
class FileLoadedEvent(Event):
    name: str
    content: str
    

def load_file(cmd: LoadFileCommand):
    print(f"EXECUTE load_file: {cmd.name}")
    with open(cmd.name) as f:
        content = f.read()
    FileLoadedEvent(name=cmd.name, content=content).handle()
    return content

def on_file_loaded(event: FileLoadedEvent):
    print(f"HANDLE FileLoadedEvent: {event.name}")


def main():
    global handler
    executor = CommandExecutor()
    handler = EventHandler()
    # Configure file loading algorithm
    executor.executors[LoadFileCommand] = load_file
    # Configure file loaded event handling algorithm
    handler.observe(FileLoadedEvent, on_file_loaded)

    command = LoadFileCommand()
    executor.execute(command)

if __name__ == "__main__":
    main()
----

Let's look at our implementation now:

- Our classes follow the single responsibility principle.
- Command and event execution logic could be bound dynamically at run-time
- Command and event execution is loosely coupled with application components through mediator objects.

As you can see now we need to think how to make the command executor and the event handler available to the code. For this we could use Dependency Injection
